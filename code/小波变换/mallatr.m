%====================================
% 一维mallat快速合成算法的实现
% 函数：mallatr
% 输入：   x—待合成的一维信号
%         N—合成所需要的级数
% 输出：   y—合成恢复后的信号
% 2009.10.21
%====================================
function y=mallatr(x,N)
lt=length(x);                   %得到序列的长度
s=x;                            %建立中间变量
y=zeros(1,lt);                  %初始化输出序列
h=[0.482962913145,0.836516303738,0.224143868042,-.129409522551]; % 得到低通滤波器
%进行N级恢复处理
for i=N:-1:1;          
s1=s(1,1:lt/2^(i));             %从分解信号中得到分解算法中的N级平滑分量
s1=dyadup(s1);                  %插零值处理
s1=s1(1,[1:length(s1)-1]);      %去掉差值过程中结尾处产生的多余零值
s2=s(1,(lt/2^(i)+1):lt/2^(i-1));%从分解信号中得到分解算法中的N级差值分量
s2=dyadup(s2);                  %插零值处理
s2=s2(1,[1:length(s2)-1]);      %去掉差值过程中结尾处产生的多余零值
hn=[h,zeros(1,(length(s1)-length(h)))];  %利用圆周卷积进行处理，故滤波器长度要待处理信号长度一致 
gn=[h(1,2),-h(1,1),zeros(1,(length(s2)-length(h))),h(1,4),-h(1,3)]; 
hr=hn(end:-1:1);                         %由分解滤波器得到恢复滤波器
gr=gn(end:-1:1);
hr=circshift(hr',1)';           %位置调整圆周右移一位
gr=circshift(gr',1)';           %位置调整圆周右移一位
c=ifft(fft(s1).*fft(hr));       %利用快速FFt实现圆周卷积，使用圆周卷积相当于对原始信号进行了周期
d=ifft(fft(s2).*fft(gr));       %延拓，减小滤波器滤波的边缘效应
w=c+d;                          %合成
s(1,1:lt/2^(i-1))=w;            %将合成的平滑分量赋给中间变量，循环继续合成
end;
y=s;                            %赋值给输出序列



